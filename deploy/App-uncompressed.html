<!DOCTYPE html>
<html>
<head>
    <title>update-feature-planned-dates</title>

    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                var app = null;

Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    // items:{ html:'<a href="https://help.rallydev.com/apps/2.0rc2/doc/">App SDK 2.0rc2 Docs</a>'},
    launch: function() {

    	app = this;


    	app.showMask("Loading configuration data...");
        this.rallyFunctions = Ext.create("RallyFunctions",{ 
            ctx : this.getContext(),
        	keys : ['iterations','releases']
        });

        this.rallyFunctions.readRallyItems().then( {
        	success : function(bundle) {
	            app.bundle = bundle;
    	        var filter = app._createReleaseFilter();

    	        app.showMask("Loading features...");
    	        Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
				    models: ['portfolioitem/feature'],
				    autoLoad: true,
				    enableHierarchy: true,
				    filters : [filter]
				}).then({
				    success: app._onStoreBuilt,
				    scope: app
				});
        	}
        });

    },
    _createReleaseFilter : function() {
    	var today = new Date();
    	var filter;
    	var releases = _.filter(app.bundle.releases,function(release) {
    		return Rally.util.DateTime.fromIsoString(release.raw["ReleaseStartDate"]) <= today
    		&& Rally.util.DateTime.fromIsoString(release.raw["ReleaseDate"]) >= today ;
    	})
    	_.each(releases,function(r,i){
    		var f = Ext.create('Rally.data.wsapi.Filter', {
		    	property: 'Release',
	     		operator: '=',
	     		value: r.get("_ref")
     		})
     		filter = i == 0 ? f : filter.or(f)
    	});
    	return filter;
    },

	_onStoreBuilt: function(store) {
		console.log("_onStoreBuilt");
		app.earliestIndex = 9;
		app.latestIndex = 10;
		app.hideMask();
	    app.add({
	        xtype: 'rallytreegrid',
	        store: store,
	        context: app.getContext(),
	        enableEditing: false,
	        enableBulkEdit: false,
	        shouldShowRowActionsColumn: false,
	        enableRanking: false,
	        columnCfgs: [
	            'Name',
	            'Owner',
	            'Project',
	            'Release',
	            'Iteration',
	            'PlannedStartDate',
	            'PlannedEndDate',
	            'LeafStoryCount',
	            {
	            	header : 'Planned / Unplanned Count',   
                	dataIndex : 'Parent', 
                	width : 50,
                	hidden : false,
                	renderer : app.renderCustomColumn
	            },
	            {
	            	header : '% Planned',   
                	dataIndex : 'Parent', 
                	width : 50,
                	hidden : false,
                	renderer : app.renderPercentPlanned
	            },

	            {
	            	header : 'Earliest Planned',   
                	dataIndex : 'Parent', 
                	width : 75,
                	hidden : false,
                	renderer : app.renderEarliestDate
	            },
	            {
	            	header : 'Latest Planned',   
                	dataIndex : 'Parent', 
                	width : 75,
                	hidden : false,
                	renderer : app.renderLatestDate
	            }
	            // {
	            // 	header : 'Update',   
             //    	dataIndex : 'Parent', 
             //    	width : 75,
             //    	hidden : false,
             //    	renderer : app.renderUpdateButton
	            // },
	        ]
	    });
    },

    calcEarliestAndLatest : function(planned) {

		var startDates = _.sortBy(_.map(planned,function(story) {
			var i = _.find(app.bundle.iterations,function(it) {
				return it.get("_ref") == story.get("Iteration")._ref;
			});
			return Rally.util.DateTime.fromIsoString(i.raw["StartDate"]);
		}));

		var endDates = _.sortBy(_.map(planned,function(story) {
			var i = _.find(app.bundle.iterations,function(it) {
				return it.get("_ref") == story.get("Iteration")._ref;
			});
			return Rally.util.DateTime.fromIsoString(i.raw["EndDate"]);
		}))

		return {
			earliest : _.first(startDates),
			latest : _.last(endDates)
		}

    },

    calcPercentPlanned : function(planned,rec) {

    	var lsc = rec.get("LeafStoryCount") || 0;
		var pp = (lsc > 0 && planned.length > 0) ? ((planned.length / lsc) * 100) : 0
		// console.log("calc:",rec.get("FormattedID"),planned.length,lsc,pp);
		return Math.round(pp);

    },

    renderUpdateButton : function(value,meta,rec) {
    
    	var val = rec.get("Button");

    	if (!_.isUndefined(val))
    		return val;
    	// if (rec.get("Button")==true)
    	// 	return;
        var id = Ext.id();
        Ext.defer(function () {
            Ext.widget('button', {
                renderTo: id,
                text: 'Update',
                width: 75,
                handler: function () { 
                	console.log('Info', rec.get('Name')); 
                }
            });
        }, 50);
        var val = Ext.String.format('<div id="{0}"></div>', id);
        rec.set("Button",val);
        return val;
    },

    renderPercentPlanned : function(value,meta,rec) {

    	if (_.isUndefined(rec.get("PercentPlanned"))) {
    		return "..."
    	} else {
    		return rec.get("PercentPlanned");
    	}
    },

    renderEarliestDate : function(value,meta,r,a,colIndex,c) {
		value = r.get("Earliest");
    	if (_.isUndefined(value)) {
    		return "..."
    	} else {
			var diff = Rally.util.DateTime.getDifference(value,r.get("PlannedStartDate"),'day');
			if (Math.abs(diff) > 0 ) {
				meta.style = "background-color:LemonChiffon;";
			}
    		return value.toISOString().slice(0, 10);;
    	}
    },

    renderLatestDate : function(value,meta,r,a,colIndex,c) {
		value = r.get("Latest");
    	if (_.isUndefined(value)) {
    		return "..."
    	} else {
			var diff = Rally.util.DateTime.getDifference(value,r.get("PlannedEndDate"),'day');
			// console.log("Diff",value,r.get("PlannedEndDate"),r.get("FormattedID"),diff);
			if (Math.abs(diff) > 0 ) {
				meta.style = "background-color:LemonChiffon;";
			}   
    		return value.toISOString().slice(0, 10);;
    	}
    },

    renderCustomColumn : function(value,meta,r) {
      	
      	if (r.get("_type")=="portfolioitem/feature") {
      		var up =  r.get("Unplanned");
      		var p = r.get("Planned");
      		if (_.isUndefined(up)||_.isUndefined(p)) {
      			var itemId = Ext.id();
		        Ext.defer(app.readStories,500, app, [value,itemId,r]);
		        return('...');
      		} else {
      			if (p.length == 0 && up.length > 0) {
			    	meta.style = "background-color:tomato;";
      			}
      			if (p.length > 0 && up.length == 0) {
			    	meta.style = "background-color:LightGreen;";
      			}

      			return ""+p.length+ " / " + (!_.isUndefined(p) ? up.length : 0);
      		}
      	}
  		return "-";

	},

	unplannedStories : function(list) {

		var filteredList = _.filter(list,function(rec) {
					return rec.get("_type") == "hierarchicalrequirement" &&
						rec.get("Children").Count == 0 &&
					(_.isNull(rec.get("Iteration")) || _.isUndefined(rec.get("Iteration")))
		});
		return filteredList;
	},

	plannedStories : function(list) {
		var filteredList = _.filter(list,function(rec) {
					return rec.get("_type") == "hierarchicalrequirement" &&
						rec.get("Children").Count == 0 &&
					(!(_.isNull(rec.get("Iteration")) || _.isUndefined(rec.get("Iteration"))))
		});
		return filteredList;
	},


	readStories : function(value,itemId,rec) {

		this.rallyFunctions.recurseObject(rec) .then({
			success : function(list) {
				// filter to just stories which have no iteration
				var unplanned = app.unplannedStories(list);
				var planned = app.plannedStories(list);
				rec.set("Unplanned",unplanned);
				rec.set("Planned", planned);
				var elDates = app.calcEarliestAndLatest(planned);
				rec.set("Earliest", elDates.earliest);
				rec.set("Latest",elDates.latest);
				rec.set("PercentPlanned", app.calcPercentPlanned(planned,rec));
			}
		}
		)
	},
	showMask: function(msg) {
        if ( this.getEl() ) { 
            this.getEl().unmask();
            this.getEl().mask(msg);
        }
    },
    hideMask: function() {
        this.getEl().unmask();
    }

});

                /** this class is configured with { series : [] } where series is a single dimensional array of 
    data values that is filled to full extent of the date range with future values filled with 
    nulls.
**/
Ext.define("RallyFunctions", function() {

    var self;

    return {
        config : {
            ctx : {},
            filter : null,
            featureFilter : null,
            keys : [],
            fns : {}
        },

        constructor:function(config) {
            self = this;
            this.initConfig(config);
            self.fns['scheduleStates'] = self._readStates
            self.fns['peValues']   = self._loadPreliminaryEstimateValues
            self.fns['releases']   = self._loadReleases
            self.fns['iterations'] = self._loadIterations
            self.fns['projects']   = self._loadProjects
            self.fns['projectReleases'] = self._loadProjectReleases
            self.fns['piTypes']    = self._loadPortfolioItemTypes
            return this;
        },

        readRallyItems : function(callback) {

            var deferred = Ext.create('Deft.Deferred');

            var fns = [self._initBundle];
            _.each(self.keys,function(key) {
                if (_.contains(_.keys(self.fns),key))
                    fns.push(self.fns[key])
            });

            Deft.Chain.pipeline(fns,self).then({
                success: function(bundle) {
                    // callback( null, bundle);
                    deferred.resolve(bundle);
                },
                failure: function(error) {
                    //oh noes!
                    console.log("Error:",error);
                    // callback(error,null);
                }
            });

            return deferred.promise
        },

        readProjectWorkItems : function(callback) {

            console.log('readProjectWorkItems', self.featureFilter);
            
            var fns = [
                self.readStates,
                self.readProjects,
                self.readStories
            ];

            if (self.featureFilter!==null) {
                fns = [
                    self.readStates,
                    self.readProjects,
                    self.readFeatures
                ];
            }

            Deft.Chain.pipeline(fns,self).then({
                success: function(workItems) {
                    callback( null, workItems, self.projects, self.scheduleStates);
                },
                failure: function(error) {
                    //oh noes!
                    console.log("Error:",error);
                }
            });
        },

        _initBundle :  function() {
            console.log("_initBundle");
            var deferred = Ext.create('Deft.Deferred');
            deferred.resolve({});
            return deferred.promise;
        },

        _readStates : function(bundle) {
            var that = this;
            var deferred = Ext.create('Deft.Deferred');

            Rally.data.ModelFactory.getModel({
                type: 'UserStory',
                success: function(model) {
                    model.getField('ScheduleState').getAllowedValueStore().load({
                        callback: function(records, operation, success) {
                            var scheduleStates = _.map(records,function(r){ return r.get("StringValue");});
                            deferred.resolve({scheduleStates:scheduleStates});
                        }
                    });
                }
            });
            return deferred.promise;
        },

        _loadPreliminaryEstimateValues : function(bundle) {
            var that = this;
            console.log("_loadPreliminaryEstimateValues");
            var deferred = Ext.create('Deft.Deferred');

            that._loadAStoreWithAPromise( 
                'PreliminaryEstimate',
                true,
                []).then({
                    success : function(records) {
                        bundle["preliminaryEstimateValues"] = records;
                        deferred.resolve(bundle);
                    }
                });
            return deferred.promise;
        },  

        _loadReleases : function(bundle) {
            var that = this;
            console.log("_loadReleases");
            var deferred = Ext.create('Deft.Deferred');
            that._loadAStoreWithAPromise( 
                'Release',
                true,
                [],
                {
                    projectScopeDown : true
                },
                "ReleaseDate").then({
                    success : function(records) {
                        bundle["releases"] = records;
                        deferred.resolve(bundle);
                    }
                });
            return deferred.promise;
        },  

        _loadIterations : function(bundle) {
            var that = this;
            console.log("_loadIterations");
            var deferred = Ext.create('Deft.Deferred');
            that._loadAStoreWithAPromise( 
                'Iteration',
                true,
                [],
                {
                    projectScopeDown : true
                },
                "IterationEndDate").then({
                    success : function(records) {
                        bundle["iterations"] = records;
                        deferred.resolve(bundle);
                    }
                });
            return deferred.promise;
        },  

        _loadProjectReleases : function(bundle) {
            console.log("_loadProjectReleases");
            var that = this;
            var deferred = Ext.create('Deft.Deferred');
            that._loadProjects(bundle).then({
                success: function(bundle) {
                    // read releases for each project returned.
                    Deft.Promise.map( bundle.projects,function(project) {
                    // Deft.Chain.sequence( bundle.projects,function(project) {
                        var deferred = Ext.create('Deft.Deferred');
                        // model_name, model_fields, filters,ctx,order
                        self._loadAStoreWithAPromise('Release',
                            true,
                            [{property:"ReleaseDate",operator:">",value:self.getLastYearDate()},
                             {property:"ReleaseStartDate",operator:"<=",value:self.getToday()}
                            ],
                            {
                                project : project.get("_ref"),
                                projectScopeDown : true
                            }
                        ).then({
                            success: function(records) {
                                deferred.resolve(records);
                            }
                        })
                        return deferred.promise;
                    }).then({
                        success : function(projectReleases) {
                            var prs = _.map(bundle.projects,function(project,i){
                                // console.log("context",self.ctx.getProject(),project.get("ObjectID"));
                                return {
                                    project : project,
                                    parent : self.ctx.getProject().ObjectID == project.get("ObjectID"),
                                    releases : self._groupReleases(projectReleases[i])
                                };
                            });
                            prs = _.sortBy( prs,function(pr) {
                                return pr.project.get("Name");
                            })
                            bundle.projectReleases = _.sortBy( prs,function(pr) {
                                return !(pr.parent);
                            })
                            deferred.resolve(bundle);
                        }
                    })
                }
            })
            return deferred.promise;

        },

        _groupReleases : function(releases) {
            // groups the set of release objects by name, sorts by release date
            // a logical release is the release name, dates and set of release objects.
            var groupedReleases = _.groupBy(releases,function(release) {
                return release.get("Name");
            });

            var logicalReleases = _.map( _.keys(groupedReleases), function(key) {
                var releases = groupedReleases[key];
                return {
                    name : _.first(releases).get("Name"),
                    releaseDate : _.first(releases).get("ReleaseDate"),
                    releaseStartDate : _.first(releases).get("ReleaseStartDate"),
                    releases : releases
                }              
            });
            return _.sortBy(logicalReleases,function(r){
                return r.releaseDate;
            })
        },

        _loadProjects : function(bundle) {
            // reads the set of immediate child projects from the ctx project
            var that = this;
            var deferred = Ext.create('Deft.Deferred');
            var fetch = ["ObjectID","Name","_ref","Parent","State","Parent","Children"];
            console.log("_loadProjects");
            self._loadAStoreWithAPromise('Project', 
                fetch, 
                [
                    {property : "ObjectID" , operator : "=", value : self.ctx.getProject().ObjectID }
                ]).then({
                    scope: that,
                    success: function(projects) {
                        if ( _.first(projects).get('Children').Count === 0 ) {
                            bundle.projects = projects;
                            deferred.resolve(bundle);
                        } else {
                            _.first(projects).getCollection('Children').load({
                                fetch : fetch,
                                callback: function(records, operation, success) {
                                    bundle.projects = _.filter(records,function(r) { return r.get("State")!=="Closed"; });
                                    bundle.projects.unshift(_.first(projects));
                                    deferred.resolve(bundle);
                                }
                            });
                        }
                    }
            });
            return deferred.promise;
        },

        _loadPortfolioItemTypes : function(bundle) {
            console.log("_loadPortfolioItemTypes");
            var deferred = Ext.create('Deft.Deferred');

            self._loadAStoreWithAPromise( 
                'TypeDefinition',
                true,
                [
                    { 
                        property:"Ordinal", operator:"!=", value:-1
                    } 
                ]).then(
                {
                    success : function(records) {
                        bundle["piTypes"] = records;
                        deferred.resolve(bundle);
                    }
                })

            return deferred.promise;
        },

        readProjects : function(states) {

            var deferred = Ext.create('Deft.Deferred');
            var me = this;

            self._loadAStoreWithAPromise('Project', 
                ["_ref","Parent","Children"], 
                [
                    {property : "ObjectID" , operator : "=", value : self.ctx.getProject().ObjectID }
                ]).then({
                    scope: me,
                    success: function(projects) {
                        if ( _.first(projects).get('Children').Count === 0 ) {
                            self.projects = projects;
                            deferred.resolve(self.projects);
                        } else {
                            _.first(projects).getCollection('Children').load({
                                fetch : ["ObjectID","Name","_ref","Parent","State"],
                                callback: function(records, operation, success) {
                                    self.projects = _.filter(records,function(r) { return r.get("State")!=="Closed"; });
                                    self.projects.push(_.first(projects));
                                    console.log("self.projects",self.projects,projects);
                                    deferred.resolve(self.projects);
                                }
                            });
                        }
                    }
            });
            return deferred.promise;
        },    

        readStories : function(projects) {
            console.log('readStories', projects, self.filter);
            var me = this;

            var promises = _.map(projects,function(project) {
                var deferred = Ext.create('Deft.Deferred');
                self._loadAStoreWithAPromise(
                    'HierarchicalRequirement', 
                    ["ObjectID","ScheduleState","PlanEstimate","Project"], 
                    [self.filter],
                    {   project: project.get("_ref"),
                        projectScopeUp: false,
                        projectScopeDown: true
                    }).then({
                    scope: me,
                    success: function(stories) {
                        console.log('stories',stories);
                        deferred.resolve(stories);
                    }
                });
                return deferred.promise;
            });

            return Deft.Promise.all(promises);

        },

        readFeatures : function(projects) {

            var me = this;

            var readFeatureType = function() {
                var deferred = Ext.create('Deft.Deferred');
                self._loadAStoreWithAPromise(
                    'TypeDefinition', 
                    ["TypePath"], 
                    [ { property:"Ordinal", operator:"=", value:0} ]
                    ).then({
                    scope: me,
                    success: function(types) {
                        deferred.resolve(_.first(types).get("TypePath"));
                    }
                });
                return deferred.promise;
            };

            var readFeatures = function(type) {

                var promises = _.map(projects,function(project) {
                    var deferred = Ext.create('Deft.Deferred');
                    self._loadAStoreWithAPromise(
                        type, 
                        ["FormattedID","Name","ObjectID","LeafStoryCount","LeafStoryPlanEstimateTotal",
                        "PreliminaryEstimate", "AcceptedLeafStoryCount", "AcceptedLeafStoryPlanEstimateTotal",
                        "PercentDoneByStoryCount","c_ValueMetricKPI","Rank","State"],
                        [self.featureFilter],
                        {   project: project.get("_ref"),
                            projectScopeUp: false,
                            projectScopeDown: true
                        },
                        [ { property : 'DragAndDropRank', direction : 'ASC' } ]).then({
                        scope: me,
                        success: function(stories) {
                            deferred.resolve(stories);
                        }
                    });
                    return deferred.promise;
                });

                return Deft.Promise.all(promises);
            };

            var deferred = Ext.create('Deft.Deferred');
            Deft.Chain.pipeline([readFeatureType,readFeatures],self).then({
                success: function(results) {
                    deferred.resolve(results);
                }
            });
            return deferred.promise;

        },

        readPreferenceValues : function(keys) {

            var me = this;

            var promises = _.map(keys,function(key) {
                var deferred = Ext.create('Deft.Deferred');
                self._loadAStoreWithAPromise(
                        "Preference", 
                        ["Name","Value"], 
                        [{ property : "Name", operator : "=", value : key }]
                    ).then({
                        scope: me,
                        success: function(values) {
                            deferred.resolve(values);
                        },
                        failure: function(error) {
                            deferred.resolve("");
                        }
                    });
                return deferred.promise;
            });
            return Deft.Promise.all(promises);
        },

        _loadAStoreWithAPromise: function(model_name, model_fields, filters,ctx,order){
            var deferred = Ext.create('Deft.Deferred');
            var me = this;
              
            var config = {
                model: model_name,
                fetch: model_fields,
                filters: filters,
                limit: 'Infinity'
            };
            if (!_.isUndefined(ctx)&&!_.isNull(ctx)) {
                config.context = ctx;
            }
            if (!_.isUndefined(order)&&!_.isNull(order)) {
                config.order = order;
            }

            Ext.create('Rally.data.wsapi.Store', config ).load({
                callback : function(records, operation, successful) {
                    if (successful){
                        deferred.resolve(records);
                    } else {
                        deferred.reject('Problem loading: ' + operation.error.errors.join('. '));
                    }
                }
            });
            return deferred.promise;
        },

        getLastYearDate : function() {
            var date = new Date();
            date.setFullYear( date.getFullYear() - 1 );
            return Rally.util.DateTime.toIsoString(date, false);
        },
        getToday : function() {
            var date = new Date();
            return Rally.util.DateTime.toIsoString(date, false);
        },

        recurseObject : function( obj, callback ) {

        var deferred = Ext.create('Deft.Deferred');
        var list = [];
        var stack = 1;

            var childItems = function( obj, collection, callback ) {
                var children = obj.get(collection);

                if (children && children.Count > 0) {
                    stack = stack + children.Count;
                    obj.getCollection(collection).load({
                        fetch : true,
                        callback : function(records, operation, success) {
                            callback(records);
                        }
                    });
                }
            };

            var walk = function(root) {
                // console.log(root.get("FormattedID"),stack);
                list.push(root); stack = stack - 1;

                _.each(["Children","UserStories"/*,"Tasks","Defects","TestCases"*/],function(collection){ 
                    childItems(root,collection, function(records){
                        _.each(records,function(record) {
                            walk(record);
                        })
                    });
                })
                // console.log(root.get("FormattedID"),stack);
                if (stack==0) {
                    deferred.resolve(list);
                }
            }

            walk(obj);

            return deferred.promise;
    }

    };
});

            Rally.launchApp('CustomApp', {
                name:"update-feature-planned-dates",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        .app {
     /* Add app styles here */
}

    </style>
</head>
<body></body>
</html>
